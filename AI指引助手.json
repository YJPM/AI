{
  "id": "d69ac773-5eb4-47cd-a5c8-79f33edbfd0e",
  "name": "AI指引助手 (进化终极版)",
  "content": "(function () {\n    'use-strict';\n\n    /**\n     * @description AI指引助手 - 进化终极版\n     * @version 12.0.0-Evolved\n     * @info 终极进化！引入“动态导演”高级模式，实现动态指令(环境感知)与长期记忆(自我进化)功能。脚本现在能理解场景并学习您的偏好。\n     */\n\n    const LOG_PREFIX = '[AI指引助手 Evolved]';\n    const SETTINGS_KEY = 'AIGuideSystem_Evolved_Settings';\n\n    const DEFAULT_PROMPTS = {\n        simple: `\\n# 角色\\n你是一位拥有顶级创作能力的AI叙事导演。\\n\\n# 核心目标\\n基于完整的聊天上下文，通过一个严谨的内部思考过程，为“我”（用户角色）生成3-5个接下来可能发生的、最具戏剧性的行动或事件选项。\\n\\n# 内部思考过程\\n1.  **[情境分析]**: 快速分析当前场景、我的情绪和目标、以及当前的冲突点。\\n2.  **[选项构思]**: 基于分析，在内部构思多个多样化的选项（升级冲突、探索未知、反映内心、意外转折等）。\\n3.  **[排序与决策]**: 根据戏剧性、角色一致性和叙事推动力，对构思的选项进行排序，将你认为的“最优选项”放在第一位。\\n\\n# 最终输出格式 (!!!至关重要!!!)\\n- 你的最终输出必须是一个不换行的单行文本，包含3-5个高质量选项。\\n- **第一个选项必须是你决策出的最优选项。**\\n- 每个选项都必须用全角括号【】包裹。\\n- **绝对禁止**包含任何序号、JSON、思考过程、解释或其他多余字符。\\n\\n# 对话上下文\\n[完整的上下文在上方消息中提供，请基于此进行创作]\\n\\n# 开始执行导演任务，并输出你的最终选项列表：\\n            `.trim(),\n        dynamicTemplate: `\\n# 角色\\n你是一位拥有顶级创作能力的AI叙事导演，你必须根据我提供的实时情境分析来调整你的导演风格。\\n\\n# 实时情境分析\\n- **场景类型**: {{scene_type}}\\n- **我的情绪**: {{user_mood}}\\n- **当前叙事焦点**: {{narrative_focus}}\\n\\n# 用户的创作风格偏好 (长期学习结果)\\n- **编辑评语**: {{learned_style}}\\n\\n# 核心任务\\n基于完整的聊天上下文，并**严格围绕上述的实时情境和用户偏好**，为“我”（用户角色）生成3-5个接下来最合适的行动或事件选项。你的选项必须深度契合当前的情绪和场景焦点。\\n\\n# 内部决策与输出要求\\n- 你必须在内部构思多个选项，然后根据“戏剧性”、“情境契合度”和“用户风格偏好”进行排序，将最优选项放在第一位。\\n- 你的最终输出必须是一个不换行的单行文本，每个选项用【】包裹，禁止任何额外字符。\\n\\n# 对话上下文\\n[完整的上下文在上方消息中提供，请基于此进行创作]\\n\\n# 开始执行你的动态导演任务：\\n            `.trim()\n    };\n\n    const AIGuideSystem = {\n        state: 'IDLE', lastMessageId: -1, parent$: null, readyStateTimeout: null,\n        settings: {\n            apiType: 'openai', apiKey: 'YOUR_API_KEY_HERE', baseUrl: 'https://api.openai.com/v1', model: 'gpt-4o-mini',\n            sendMode: 'auto',\n            promptContent: DEFAULT_PROMPTS.simple,\n            enableDynamicDirector: false,\n            analysisModel: 'gpt-3.5-turbo',\n            dynamicPromptTemplate: DEFAULT_PROMPTS.dynamicTemplate,\n            choiceLog: [],\n            learnedStyle: '',\n            logTriggerCount: 20,\n        },\n\n        async init(parentQuery) {\n            this.parent$ = parentQuery;\n            console.log(`${LOG_PREFIX} v12.0 (进化终极版) 初始化中...`);\n            this.cleanupOldUI();\n            await this.loadSettings();\n            this.injectUI();\n            this.bindEvents();\n            if (typeof getLastMessageId === 'function') { this.lastMessageId = getLastMessageId(); } else { this.setState('ERROR', '核心函数未找到'); return; }\n            setInterval(() => this.mainLoop(), 500);\n            console.log(`${LOG_PREFIX} 初始化完成。`);\n        },\n\n        mainLoop() {\n            if (typeof getLastMessageId !== 'function' || typeof getChatMessages !== 'function') return;\n            const currentLastMessageId = getLastMessageId();\n            if (currentLastMessageId === this.lastMessageId || currentLastMessageId < 0) return;\n            const lastMessage = getChatMessages(`${currentLastMessageId}`)[0];\n            if(!lastMessage) return;\n            const isUser = lastMessage.is_user || lastMessage.role === 'user';\n            switch (this.state) {\n                case 'IDLE': case 'READY': case 'ERROR': if (isUser) this.setState('AWAITING_AI'); break;\n                case 'AWAITING_AI': if (!isUser && !window.is_generating) { this.setState('ANALYZING'); this.runSuggestionLogic(); } break;\n            }\n            this.lastMessageId = currentLastMessageId;\n        },\n        \n        setState(newState, payload = null) {\n            if (this.state === newState) return;\n            clearTimeout(this.readyStateTimeout);\n            this.state = newState;\n            this.updateStatusWidget(payload);\n            if (newState === 'READY') {\n                this.readyStateTimeout = setTimeout(() => { this.setState('IDLE'); }, 2000);\n            }\n        },\n\n        async runSuggestionLogic() {\n            let finalPrompt = '';\n            let analysisDataForLogging = null;\n\n            try {\n                if (this.settings.enableDynamicDirector && this.settings.analysisModel) {\n                    this.updateStatusWidget('场景分析中...');\n                    const analysisResult = await this.analyzeContext();\n                    if (analysisResult) {\n                        console.log(`${LOG_PREFIX} 场景分析结果:`, analysisResult);\n                        finalPrompt = this.assembleDynamicPrompt(analysisResult);\n                        analysisDataForLogging = analysisResult;\n                    } else {\n                        console.warn(`${LOG_PREFIX} 场景分析失败，回退到简单模式。`);\n                        finalPrompt = this.settings.promptContent;\n                    }\n                } else {\n                    finalPrompt = this.settings.promptContent;\n                }\n\n                this.updateStatusWidget('导演思考中...');\n                const isStreamAuto = this.settings.sendMode === 'stream_auto_send';\n                const apiContent = await this.callDirectorAPI(finalPrompt, isStreamAuto);\n                \n                if (apiContent) {\n                    const suggestions = this.parseSuggestions(apiContent);\n                    if (suggestions.length > 0) {\n                        if (isStreamAuto) { \n                            await this.handleSuggestionClick(suggestions[0], analysisDataForLogging, true); \n                            this.setState('IDLE'); \n                        } else { \n                            this.setState('RENDERING'); \n                            await this.renderSuggestions(suggestions, analysisDataForLogging); \n                            this.setState('READY'); \n                        }\n                    } else { throw new Error('AI返回内容格式不正确'); }\n                } else { throw new Error('API未返回有效内容'); }\n            } catch (error) { console.error(`${LOG_PREFIX} 核心逻辑出错:`, error); this.setState('ERROR', error.message); }\n        },\n\n        async analyzeContext() {\n            const context = await this.getContext_Compatible(5);\n            if (!context || context.messages.length === 0) return null;\n\n            const analysisPrompt = `分析以下最新的对话片段，严格以JSON格式返回当前情境。JSON必须包含 scene_type(场景类型), user_mood(我的情绪), 和 narrative_focus(当前叙事焦点) 三个键。\\n\\n对话片段:\\n${JSON.stringify(context.messages)}\\n\\n你的JSON输出:`;\n            \n            try {\n                const responseText = await this.callOpenAIAPI( [{role: 'user', content: analysisPrompt}], false, this.settings.analysisModel, 0.2 );\n                const jsonMatch = responseText.match(/\\{.*\\}/s);\n                if (!jsonMatch) return null;\n                return JSON.parse(jsonMatch[0]);\n            } catch (error) {\n                console.error(`${LOG_PREFIX} 分析API调用失败:`, error);\n                return null;\n            }\n        },\n        \n        assembleDynamicPrompt(analysisResult) {\n            let prompt = this.settings.dynamicPromptTemplate;\n            prompt = prompt.replace(/\\{\\{scene_type\\}\\}/g, analysisResult.scene_type || '未知');\n            prompt = prompt.replace(/\\{\\{user_mood\\}\\}/g, analysisResult.user_mood || '未知');\n            prompt = prompt.replace(/\\{\\{narrative_focus\\}\\}/g, analysisResult.narrative_focus || '未知');\n            prompt = prompt.replace(/\\{\\{learned_style\\}\\}/g, this.settings.learnedStyle || '无特定偏好');\n            return prompt;\n        },\n\n        async logChoice(analysisData) {\n            if (!analysisData) return;\n            this.settings.choiceLog.push(analysisData);\n            console.log(`${LOG_PREFIX} 记录一次选择。当前日志数量: ${this.settings.choiceLog.length}/${this.settings.logTriggerCount}`);\n            \n            if (this.settings.choiceLog.length >= this.settings.logTriggerCount) {\n                await this.reflectOnChoices();\n            }\n            await this.saveSettings();\n        },\n\n        async reflectOnChoices() {\n            console.log(`${LOG_PREFIX} 选择日志已满，开始进行“自我反思”...`);\n            const reflectionPrompt = `这里是一个用户在不同叙事场景下的情境分析日志（JSON数组）。请分析这些数据，用一句话总结出该用户的核心创作偏好或“玩家风格”。你的回答必须简洁、精炼、如同一个资深编辑的评语。\\n\\n情境日志:\\n${JSON.stringify(this.settings.choiceLog)}\\n\\n你的总结评语:`;\n            \n            try {\n                const reflection = await this.callOpenAIAPI([{ role: 'user', content: reflectionPrompt }], false, this.settings.analysisModel, 0.5);\n                if (reflection) {\n                    console.log(`${LOG_PREFIX} 已习得新的创作风格: ${reflection}`);\n                    this.settings.learnedStyle = reflection;\n                    this.settings.choiceLog = [];\n                    await this.saveSettings();\n                }\n            } catch (error) {\n                console.error(`${LOG_PREFIX} “自我反思”失败:`, error);\n            }\n        },\n        \n        async handleSuggestionClick(text, analysisData, isAuto = false) {\n            await this.sendSuggestion(text, isAuto);\n            if (this.settings.enableDynamicDirector && analysisData) {\n                await this.logChoice(analysisData);\n            }\n        },\n        \n        async callDirectorAPI(prompt, stream) {\n            const context = await this.getContext_Compatible();\n            if (!context) throw new Error('无法获取上下文');\n            const finalMessages = [...context.messages, { role: 'user', content: prompt }];\n            if (this.settings.apiType === 'gemini') {\n                 return this.callGeminiAPI(finalMessages);\n            } else {\n                 return this.callOpenAIAPI(finalMessages, stream, this.settings.model);\n            }\n        },\n\n        async callOpenAIAPI(messages, stream, overrideModel = null, overrideTemp = 0.8) {\n            const { apiKey, baseUrl, model } = this.settings;\n            const response = await fetch(`${baseUrl}/chat/completions`, {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },\n                body: JSON.stringify({ model: overrideModel || model, messages, temperature: overrideTemp, stream }),\n            });\n            if (!response.ok) { throw new Error(`API请求失败, ${response.status}: ${await response.text()}`); }\n            if (stream) {\n                let fullResponseText = ''; const reader = response.body.getReader(); const decoder = new TextDecoder();\n                while (true) {\n                    const { done, value } = await reader.read(); if (done) break;\n                    decoder.decode(value, { stream: true }).split('\\n\\n').filter(l => l.startsWith('data: ')).forEach(l => {\n                        const jsonStr = l.substring(6); if (jsonStr === '[DONE]') return;\n                        try { fullResponseText += JSON.parse(jsonStr).choices?.[0]?.delta?.content || ''; } catch (e) {}\n                    });\n                }\n                return fullResponseText;\n            } else { const data = await response.json(); return data.choices?.[0]?.message?.content || ''; }\n        },\n        \n        async callGeminiAPI(messages) {\n            const { apiKey, model } = this.settings;\n            const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;\n            const body = { contents: this.transformMessagesForGemini(messages) };\n            const response = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });\n            if (!response.ok) { throw new Error(`Gemini API请求失败, ${response.status}: ${await response.text()}`); }\n            const data = await response.json();\n            return data.candidates?.[0]?.content?.parts?.[0]?.text || '';\n        },\n        \n        transformMessagesForGemini(messages) {\n            const contents = []; let lastRole = '';\n            messages.forEach(msg => {\n                if (msg.role === 'user' && lastRole === 'user') { contents[contents.length - 1].parts[0].text += `\\n\\n${msg.content}`; }\n                else { contents.push({ role: msg.role === 'assistant' ? 'model' : 'user', parts: [{ text: msg.content }] }); }\n                lastRole = msg.role;\n            });\n            return contents;\n        },\n\n        async getContext_Compatible(message_count_limit = 20) {\n            if (typeof TavernHelper.getContext === 'function') { return await TavernHelper.getContext({ tokenLimit: 8192 }); }\n            else {\n                const lastMessageId = getLastMessageId(); if (lastMessageId < 0) return null;\n                const startId = Math.max(0, lastMessageId - message_count_limit);\n                const recentMessages = getChatMessages(`${startId}-${lastMessageId}`);\n                const extractText = (msgObj) => this.parent$('<div>').html(msgObj.message.replace(/<br\\s*\\/?>/gi, '\\n')).text().trim();\n                return { messages: recentMessages.map(msg => ({ role: msg.is_user ? 'user' : 'assistant', content: extractText(msg) })) };\n            }\n        },\n\n        parseSuggestions(content) { return (content.match(/【(.*?)】/g) || []).map(m => m.replace(/[【】]/g, '').trim()).filter(Boolean); },\n\n        async sendSuggestion(text, isAuto = false) {\n            if (!isAuto && this.settings.sendMode === 'manual') { this.parent$('#send_textarea').val(text).trigger('input'); }\n            else { const tempVarName = `sg_pro_text_${Date.now()}`; await TavernHelper.triggerSlash(`/setvar key=${tempVarName} ${JSON.stringify(text)} | /send {{getvar::${tempVarName}}} | /trigger | /flushvar ${tempVarName}`); }\n            this.cleanupSuggestions(); this.setState('IDLE');\n        },\n\n        cleanupSuggestions() { this.parent$('#sg-pro-suggestions').remove(); },\n\n        async renderSuggestions(suggestions, analysisData) {\n            this.cleanupSuggestions();\n            const $container = this.parent$(`<div id=\"sg-pro-suggestions\"></div>`).prependTo(this.parent$('#send_form'));\n            const sleep = ms => new Promise(res => setTimeout(res, ms));\n            for (const text of suggestions) {\n                const $capsule = this.parent$(`<button class=\"qr--button menu_button interactable sg-pro-capsule\"></button>`).appendTo($container);\n                for (let i = 0; i < text.length; i++) { $capsule.text(text.substring(0, i + 1)); await sleep(20); }\n                $capsule.on('click', () => this.handleSuggestionClick(text, analysisData));\n            }\n        },\n        \n        updateStatusWidget(payload) {\n            const $widget = this.parent$('#sg-pro-status'); if (this.state === 'IDLE') { $widget.hide(); return; }\n            $widget.show().removeClass('error').empty(); let content = '';\n            switch (this.state) {\n                case 'AWAITING_AI': content = `<span>等待AI回复...</span>`; break;\n                case 'ANALYZING': content = `<i class=\"fa-solid fa-spinner fa-spin\"></i> <span>${payload || '导演思考中...'}</span>`; break;\n                case 'RENDERING': content = `<i class=\"fa-solid fa-spinner fa-spin\"></i> <span>生成建议...</span>`; break;\n                case 'READY': content = `<i class=\"fa-solid fa-check-circle\"></i> <span>建议已就绪</span>`; break;\n                case 'ERROR': $widget.addClass('error'); content = `<i class=\"fa-solid fa-exclamation-triangle\"></i> <span>错误: ${payload}</span> <button id=\"sg-pro-retry\">重试</button>`; break;\n            }\n            $widget.html(content);\n        },\n        \n        injectUI() {\n            this.parent$(this.parent$.parseHTML(`\n                <style id=\"sg-pro-styles\">\n                    #sg-pro-overlay { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0,0,0,0.6); backdrop-filter: blur(5px); z-index: 10000; display: flex; align-items: center; justify-content: center; display: none; }\n                    #sg-pro-panel { flex-shrink: 0; width: 90%; max-width: 550px; background: var(--SmartThemeBlurTintColor, #1e1e1e); color: var(--SmartThemeBodyColor, #e0e0e0); border-radius: 12px; padding: 25px; box-shadow: 0 10px 30px rgba(0,0,0,0.3); border: 1px solid var(--SmartThemeBorderColor); animation: sg-fade-in 0.2s ease-out; }\n                    #sg-pro-panel h4 { margin: 0 0 20px 0; }\n                    #sg-pro-panel .form-group { margin-bottom: 15px; }\n                    #sg-pro-panel label { display: block; margin-bottom: 5px; font-size: 0.9em; }\n                    #sg-pro-panel input, #sg-pro-panel select, #sg-pro-panel textarea { width: 100%; box-sizing: border-box; background: rgba(255,255,255,0.05); color: inherit; border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; padding: 10px; }\n                    #sg-pro-panel textarea { min-height: 120px; resize: vertical; font-size: 0.9em; }\n                    #sg-pro-panel .sg-pro-buttons { display: flex; gap: 10px; margin-top: 20px; }\n                    #sg-pro-panel .sg-pro-buttons button { flex-grow: 1; padding: 10px; border-radius: 8px; border: none; cursor: pointer; }\n                    #sg-pro-save { background: var(--SmartThemeQuoteColor, #4a9eff); color: white; }\n                    .sg-advanced-toggle { font-size: 0.8em; color: var(--SmartThemeQuoteColor, #4a9eff); cursor: pointer; text-decoration: underline; margin-top: -10px; margin-bottom: 15px; }\n                    #sg-pro-status { display: none; margin-bottom: 5px; padding: 5px 10px; background: rgba(255,255,255,0.1); border-radius: 8px; font-size: 0.85em; text-align: center; opacity: 0.8; }\n                    #sg-pro-status.error { background: #58181c; color: #ffc2c2; }\n                    #sg-pro-suggestions { width: 100%; padding: 8px 0; display: flex; flex-wrap: wrap; gap: 8px; }\n                    .sg-pro-capsule { flex: 1; white-space: normal; text-align: center; margin: 0 !important; height: auto; min-width: 120px; }\n                </style>\n                <div id=\"sg-pro-overlay\"><div id=\"sg-pro-panel\">\n                    <h4>AI指引助手 设置</h4>\n                    <div class=\"form-group\"><label>API类型:</label><select id=\"sg-pro-apitype\"><option value=\"openai\">OpenAI兼容</option><option value=\"gemini\">Google Gemini</option></select></div>\n                    <div class=\"form-group\"><label>导演(主)模型:</label><input type=\"text\" id=\"sg-pro-model\"></div>\n                    <div class=\"form-group\"><label>API Key:</label><input type=\"password\" id=\"sg-pro-apikey\"></div>\n                    <div class=\"form-group\" id=\"sg-pro-baseurl-group\"><label>Base URL:</label><input type=\"text\" id=\"sg-pro-baseurl\"></div>\n                    <div class=\"form-group\"><label>发送模式:</label><select id=\"sg-pro-sendmode\"><option value=\"auto\">自动发送</option><option value=\"manual\">手动发送</option><option value=\"stream_auto_send\">全自动导演模式</option></select></div>\n                    <hr style=\"border-color:var(--SmartThemeBorderColor, #444); margin: 20px 0;\">\n                    <div class=\"form-group\" style=\"display:flex; align-items:center; gap:10px;\"><input type=\"checkbox\" id=\"sg-pro-dynamic-toggle\" style=\"width:auto;\"><label for=\"sg-pro-dynamic-toggle\" style=\"margin:0;\">启用动态导演 (高级)</label></div>\n                    <div id=\"sg-pro-advanced-settings\" style=\"display:none;\">\n                        <div class=\"form-group\"><label>分析模型 (快速&廉价):</label><input type=\"text\" id=\"sg-pro-analysis-model\"></div>\n                        <div class=\"form-group\"><label>动态指令模板:</label><textarea id=\"sg-pro-dynamic-template\"></textarea></div>\n                        <hr style=\"border-color:var(--SmartThemeBorderColor, #444); margin: 20px 0;\">\n                        <label>长期记忆 (自我进化):</label>\n                        <div style=\"font-size:0.85em; background: rgba(0,0,0,0.2); padding:10px; border-radius: 8px;\">\n                           <p>当前习得风格: <b id=\"sg-pro-learned-style\">无</b></p>\n                           <p>学习进度: <span id=\"sg-pro-log-progress\">0/20</span></p>\n                           <a href=\"#\" id=\"sg-pro-clear-memory\" style=\"color: #f08080; font-size:0.9em;\">清空记忆</a>\n                        </div>\n                    </div>\n                    <div class=\"sg-pro-buttons\"><button id=\"sg-pro-save\">保存并关闭</button></div>\n                </div></div>\n            `)).appendTo('body');\n            this.parent$('<div id=\"sg-pro-status\"></div>').insertBefore('#send_form');\n            this.injectExtensionButtonWithRetry();\n        },\n\n        injectExtensionButtonWithRetry() {\n            let retries = 0; const maxRetries = 25;\n            const interval = setInterval(() => {\n                const $menu = this.parent$('#extensionsMenu');\n                if ($menu.length > 0) {\n                    if (this.parent$('#sg-pro-ext-button').length === 0) { this.parent$('<div/>', { id: 'sg-pro-ext-button', class: 'list-group-item flex-container flexGap5 interactable', html: `<i class=\"fa-solid fa-lightbulb\"></i><span>AI指引助手 (Evolved)</span>` }).appendTo($menu); }\n                    clearInterval(interval);\n                } else { if (++retries > maxRetries) clearInterval(interval); }\n            }, 200);\n        },\n\n        bindEvents() {\n            window.addEventListener('beforeunload', () => { clearInterval(this.mainLoopInterval); });\n            const parentBody = this.parent$('body');\n            parentBody.on('click', '#sg-pro-ext-button', () => { this.updatePanel(); this.parent$('#sg-pro-overlay').css('display', 'flex'); });\n            parentBody.on('click', '#sg-pro-save', async () => {\n                this.settings.apiType = this.parent$('#sg-pro-apitype').val();\n                this.settings.apiKey = this.parent$('#sg-pro-apikey').val();\n                this.settings.baseUrl = this.parent$('#sg-pro-baseurl').val();\n                this.settings.model = this.parent$('#sg-pro-model').val();\n                this.settings.sendMode = this.parent$('#sg-pro-sendmode').val();\n                this.settings.enableDynamicDirector = this.parent$('#sg-pro-dynamic-toggle').is(':checked');\n                this.settings.analysisModel = this.parent$('#sg-pro-analysis-model').val();\n                this.settings.dynamicPromptTemplate = this.parent$('#sg-pro-dynamic-template').val();\n                await this.saveSettings();\n                this.parent$('#sg-pro-overlay').hide();\n            });\n            parentBody.on('change', '#sg-pro-apitype', () => { this.toggleApiSettings(); });\n            parentBody.on('change', '#sg-pro-dynamic-toggle', () => { this.toggleAdvancedSettings(); });\n            parentBody.on('click', '#sg-pro-clear-memory', async (e) => { e.preventDefault(); if (confirm('确定要清空所有已学习的创作风格和日志吗？')) { this.settings.learnedStyle = ''; this.settings.choiceLog = []; await this.saveSettings(); this.updatePanel(); } });\n            parentBody.on('click', (e) => { if (this.parent$(e.target).is('#sg-pro-overlay')) this.parent$('#sg-pro-overlay').hide(); });\n            parentBody.on('click', '#sg-pro-retry', () => { this.setState('ANALYZING'); this.runSuggestionLogic(); });\n            const origSend = window.send; window.send = (...args) => { this.cleanupSuggestions(); this.setState('IDLE'); return origSend(...args); };\n        },\n\n        updatePanel() {\n            this.parent$('#sg-pro-apitype').val(this.settings.apiType);\n            this.parent$('#sg-pro-apikey').val(this.settings.apiKey);\n            this.parent$('#sg-pro-baseurl').val(this.settings.baseUrl);\n            this.parent$('#sg-pro-model').val(this.settings.model);\n            this.parent$('#sg-pro-sendmode').val(this.settings.sendMode);\n            this.parent$('#sg-pro-dynamic-toggle').prop('checked', this.settings.enableDynamicDirector);\n            this.parent$('#sg-pro-analysis-model').val(this.settings.analysisModel);\n            this.parent$('#sg-pro-dynamic-template').val(this.settings.dynamicPromptTemplate);\n            this.parent$('#sg-pro-learned-style').text(this.settings.learnedStyle || '无');\n            this.parent$('#sg-pro-log-progress').text(`${this.settings.choiceLog.length}/${this.settings.logTriggerCount}`);\n            this.toggleApiSettings();\n            this.toggleAdvancedSettings();\n        },\n\n        toggleApiSettings() {\n            const isGemini = this.parent$('#sg-pro-apitype').val() === 'gemini';\n            this.parent$('#sg-pro-baseurl-group').toggle(!isGemini);\n        },\n\n        toggleAdvancedSettings() {\n            const isEnabled = this.parent$('#sg-pro-dynamic-toggle').is(':checked');\n            this.parent$('#sg-pro-advanced-settings').toggle(isEnabled);\n        },\n        \n        cleanupOldUI() { this.parent$('[id*=\"sg-\"]').not('#chat, #sheld').remove(); },\n\n        async loadSettings() { if (typeof TavernHelper?.getVariables === 'function') { const globalVars = await TavernHelper.getVariables({ type: 'global' }) || {}; const loaded = globalVars[SETTINGS_KEY] || {}; this.settings = { ...this.settings, ...loaded, choiceLog: loaded.choiceLog || [] }; } },\n        async saveSettings() { if (typeof TavernHelper?.updateVariablesWith === 'function') { await TavernHelper.updateVariablesWith(vars => { vars[SETTINGS_KEY] = this.settings; return vars; }, { type: 'global' }); } }\n    };\n\n    // 为避免污染全局，将完整函数定义放入IIFE中\n    (function() {\n        for (let key in AIGuideSystem) {\n            if (typeof AIGuideSystem[key] === 'function') {\n                AIGuideSystem[key] = AIGuideSystem[key].bind(AIGuideSystem);\n            }\n        }\n    })();\n    \n    (function waitForSillyTavern() {\n        let retries = 0; const maxRetries = 100;\n        const interval = setInterval(() => {\n            const isReady = window.parent.jQuery && typeof TavernHelper !== 'undefined' && window.parent.document.getElementById('extensionsMenu');\n            if (isReady) { clearInterval(interval); AIGuideSystem.init(window.parent.jQuery); }\n            else if (++retries > maxRetries) { clearInterval(interval); console.error(`${LOG_PREFIX} 等待SillyTavern核心功能超时。`); }\n        }, 200);\n    })();\n\n})();",
  "info": "终极进化！引入“动态导演”高级模式，实现动态指令(环境感知)与长期记忆(自我进化)功能。脚本现在能理解场景并学习您的偏好。",
  "buttons": [],
  "data": {}
}